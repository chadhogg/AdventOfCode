package aoc2020.hoggchad.day19;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Stack;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

/**
 * A solution to Advent Of Code 2020, day 19.
 * 
 * @author Chad Hogg
 */
public class Main {

	/** The path to the input file. */
	private static final String FILE_PATH = "../../inputs/day19/input";
	
	/**
	 * Runs the program.
	 * 
	 * @param args Not used.
	 * @throws FileNotFoundException If the input file cannot be read.
	 */
	public static void main(String[] args) throws FileNotFoundException {
		Scanner fileScanner = new Scanner(new File(FILE_PATH));
		Map<String, Rule> rules = readRules(fileScanner);
		Map<String, Rule> updatedRules = new HashMap<>(rules);
		updatedRules.put("8", new Rule("8: 42 | 42 8"));
		updatedRules.put("11", new Rule("11: 42 31 | 42 11 31"));
		Set<String> strings = readStrings(fileScanner);
		fileScanner.close();

		System.out.println(countStrings(rules, strings));
		System.out.println(countStrings(updatedRules, strings));
	}

	/**
	 * A first attempt at part 1.  It works, but is slow and won't work for part 2.
	 * 
	 * @param rules A map of nonterminal to the rule for replacing it.
	 * @param possible A set of strings that might or might not be in the language.
	 * @return The number of those strings that actually are in the language.
	 */
	private static int part1First(Map<String, Rule> rules, Set<String> possible) {
		Set<String> strings = enumerateStrings(rules);
		Set<String> intersection = new HashSet<>(possible);
		intersection.retainAll(strings);
		return intersection.size();
	}
	
	/**
	 * Tests whether or not a bunch of strings can be generated by a CFG.
	 * 
	 * @param rules A map of nonterminals to the rule for replacing it.
	 * @param possible A set of strings that might or might not be in the language.
	 * @return The number of those strings that are actually in the language.
	 */
	private static int countStrings(Map<String, Rule> rules, Set<String> possible) {
		int count = 0;
		for(String string : possible) {
			if(testString(rules, string)) {
				count++;
			}
		}
		return count;
	}
	/**
	 * Reads a list of production rules from a scanner.
	 * 
	 * @param fileScanner A scanner.
	 * @return A map of head -> rule containing each rule that could be read before a blank line.
	 */
	private static Map<String, Rule> readRules(Scanner fileScanner) {
		Map<String, Rule> rules = new HashMap<>();
		while(fileScanner.hasNextLine()) {
			String line = fileScanner.nextLine();
			if(line.isEmpty()) {
				break;
			}
			else {
				Rule rule = new Rule(line);
				rules.put(rule.getHead(), rule);
			}
		}
		return rules;
	}
	
	/**
	 * Reads a list of strings from a scanner.
	 * 
	 * @param fileScanner A scanner.
	 * @return A list of strings that could be found in it.
	 */
	private static Set<String> readStrings(Scanner fileScanner) {
		Set<String> strings = new HashSet<>();
		while(fileScanner.hasNextLine()) {
			strings.add(fileScanner.nextLine());
			
		}
		return strings;
	}

	/**
	 * Enumerates every string that can be generated from a CFG.
	 * If the CFG contains loops, this will run infinitely.
	 * 
	 * @param rules A map of nonterminal to production rule.
	 * @return The set of all strings in the language of the CFG.
	 */
	private static Set<String> enumerateStrings(Map<String, Rule> rules) {
		Set<String> strings = new HashSet<>();
		Stack<List<String>> incomplete = new Stack<>();
		incomplete.add(List.of("0"));
		while(!incomplete.isEmpty()) {
			List<String> partial = incomplete.pop();
			int firstNonterminal = Rule.indexOfFirstNonTerminal(partial);
			if(firstNonterminal == -1) {
				for(int index = 0; index < partial.size(); index++) {
					partial.set(index, partial.get(index).substring(1, partial.get(index).length() - 1));
				}
				strings.add(String.join("", partial));
			}
			else {
				List<List<String>> options = rules.get(partial.get(firstNonterminal)).getOptions();
				for(List<String> option : options) {
					List<String> result = new ArrayList<>();
					result.addAll(partial.subList(0, firstNonterminal));
					result.addAll(option);
					result.addAll(partial.subList(firstNonterminal + 1, partial.size()));
					incomplete.add(result);
				}
			}
		}
		return strings;
	}
	
	/**
	 * Tests whether or not a string can be generated by a CFG.
	 * 
	 * @param rules A map from nonterminal to production rule.
	 * @param string The string that might or might not be in the language.
	 * @return True if it is in the language.
	 */
	private static boolean testString(Map<String, Rule> rules, String string) {
		Stack<String> stack = new Stack<>();
		stack.push("0");
		return testString(rules, stack, string);
	}
	
	/**
	 * Tests whether or not a partially-completed PDA matching can be completed.
	 * 
	 * This is pretty much the standard CFG -> PDA conversion, with the exception that I can directly check for empty stack.
	 * But it makes a big assumption that each nonterminal always reduces to at least one terminal.
	 * This allows us to put an upper limit on the length of the stack for computations that will eventually complete.
	 * 
	 * @param rules A map from nonterminal to production rule.
	 * @param stack The stack used by the PDA.
	 * @param input The parts of the input that have not yet been matched.
	 * @return True if the matching can be completed.
	 */
	private static boolean testString(Map<String, Rule> rules, Stack<String> stack, String input) {
		if(stack.isEmpty()) {
			return input.isEmpty();
		}
		else {
			String token = stack.pop();
			if(Rule.isTerminal(token)) {
				if(!input.isEmpty() && input.charAt(0) == token.charAt(1)) {
					return testString(rules, (Stack<String>)stack.clone(), input.substring(1));
				}
				else {
					return false;
				}
			}
			else {
				for(List<String> option : rules.get(token).getOptions()) {
					Stack<String> copy = (Stack<String>)stack.clone();
					for(int optionIndex = option.size() - 1; optionIndex >= 0; optionIndex--) {
						copy.push(option.get(optionIndex));
					}
					if(copy.size() <= input.length() && testString(rules, copy, input)) {
						return true;
					}
				}
				return false;
			}
		}
	}
}
